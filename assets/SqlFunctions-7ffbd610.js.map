{"version":3,"file":"SqlFunctions-7ffbd610.js","sources":["../../src/utils/functions/SqlFunctions.ts"],"sourcesContent":["import { Row, SelectColumn } from '@sage-bionetworks/synapse-types'\nimport { SYNAPSE_ENTITY_ID_REGEX } from './RegularExpressions'\nimport {\n  ColumnMultiValueFunction,\n  ColumnMultiValueFunctionQueryFilter,\n  ColumnSingleValueFilterOperator,\n  ColumnSingleValueQueryFilter,\n  QueryFilter,\n} from '@sage-bionetworks/synapse-types'\n\nexport type SQLOperator =\n  | ColumnSingleValueFilterOperator\n  | ColumnMultiValueFunction\n\nconst WITHOUT_SYN_PREFIX = 3\nexport const QUERY_FILTERS_LOCAL_STORAGE_KEY = (key: string) =>\n  `${key}-temp-QueryFilter-array`\n\nexport function removePrefixIfSynId(value: string) {\n  if (value.match(SYNAPSE_ENTITY_ID_REGEX)) {\n    return value.substring(WITHOUT_SYN_PREFIX)\n  }\n  return value\n}\nexport const getIgnoredQueryFilterSearchParamKey = (\n  key: string,\n  namespace?: string,\n) => {\n  return `__${namespace ?? ''}_${key}`\n}\n/**\n * Look in local storage for a set of QueryFilters to apply.  In addition, given the search params,\n * generate a set of QueryFilters to narrow the the query to view just related data.\n * May return null if a QueryFilter should not be added.\n * @param sql\n * @param searchParams\n * @param operator\n * @returns\n */\nexport const getAdditionalFilters = (\n  localStorageKey: string,\n  searchParams?: Record<string, string>,\n  operator: SQLOperator = ColumnSingleValueFilterOperator.LIKE,\n): QueryFilter[] | undefined => {\n  const localStorageQueryFiltersString = localStorage.getItem(\n    QUERY_FILTERS_LOCAL_STORAGE_KEY(localStorageKey),\n  )\n  let additionalFilters: QueryFilter[] = []\n  if (localStorageQueryFiltersString) {\n    additionalFilters = JSON.parse(\n      localStorageQueryFiltersString,\n    ) as QueryFilter[]\n    // delay clearing out the value so re-rendering during React Strict mode does not destroy the filter\n    setTimeout(\n      () =>\n        localStorage.removeItem(\n          QUERY_FILTERS_LOCAL_STORAGE_KEY(localStorageKey),\n        ),\n      1000,\n    )\n  }\n  if (searchParams) {\n    const isQueryWrapperKey = (key: string) =>\n      key.startsWith('QueryWrapper') || key.startsWith('__')\n    additionalFilters = additionalFilters.concat(\n      Object.keys(searchParams || {})\n        .filter(key => !isQueryWrapperKey(key))\n        .map(key => {\n          switch (operator) {\n            case ColumnSingleValueFilterOperator.EQUAL: {\n              const filter: ColumnSingleValueQueryFilter = {\n                concreteType:\n                  'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n                columnName: key,\n                operator: operator,\n                values: [searchParams[key]],\n              }\n              return filter\n            }\n            case ColumnSingleValueFilterOperator.IN: {\n              const filter: ColumnSingleValueQueryFilter = {\n                concreteType:\n                  'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n                columnName: key,\n                operator: operator,\n                values: searchParams[key].split(','),\n              }\n              return filter\n            }\n            case ColumnMultiValueFunction.HAS: {\n              const filter: ColumnMultiValueFunctionQueryFilter = {\n                concreteType:\n                  'org.sagebionetworks.repo.model.table.ColumnMultiValueFunctionQueryFilter',\n                columnName: key,\n                function: operator,\n                values: searchParams[key].split(','),\n              }\n              return filter\n            }\n            case ColumnSingleValueFilterOperator.LIKE: {\n              // If we use a LIKE statement with a synId the backend will look for a string with the first three\n              // characters being 'syn', however, it stores synIds without 'syn', so the query will fail\n              // The backend usually parses 'syn' out, but not with the LIKE clause since its expecting a regex, so we\n              // parse this out. This will cause a bug if something matches the synId regex but is in free text.\n              const filter: ColumnSingleValueQueryFilter = {\n                concreteType:\n                  'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n                columnName: key,\n                operator: operator,\n                // Add wildcards around the value\n                values: [`%${removePrefixIfSynId(searchParams[key])}%`],\n              }\n              return filter\n            }\n            case ColumnMultiValueFunction.HAS_LIKE: {\n              const filter: ColumnMultiValueFunctionQueryFilter = {\n                concreteType:\n                  'org.sagebionetworks.repo.model.table.ColumnMultiValueFunctionQueryFilter',\n                columnName: key,\n                function: operator,\n                values: searchParams[key].split(',').map(param => {\n                  // Remove synId prefix for the same reasons as in the LIKE case\n                  return `%${removePrefixIfSynId(param)}%`\n                }),\n              }\n              return filter\n            }\n          }\n        }),\n    )\n  }\n\n  return additionalFilters.length === 0 ? undefined : additionalFilters\n}\n\n//parses synapse entity id from a sql query string\n//look for a pattern of 'from[some number of spaces]syn[somenumbers]` case insensitive\nexport const parseEntityIdFromSqlStatement = (sql: string): string => {\n  const matches = sql.match(/(from)\\s+(syn)\\d+/gi)\n  return matches && matches[0] ? matches[0].substr(5).trim() : ''\n}\n\nexport const parseEntityIdAndVersionFromSqlStatement = (\n  sql: string,\n): { entityId: string; versionNumber?: number } | null => {\n  const regex = /from\\s+(syn\\d+)(?:\\.(\\d+))?/i\n  const matches = regex.exec(sql)\n  if (!matches) {\n    return null\n  }\n  return {\n    entityId: matches[1],\n    versionNumber: matches[2] ? parseInt(matches[2]) : undefined,\n  }\n}\n\nexport const resultToJson = <T>(\n  headerColumns: SelectColumn[],\n  rowColumns: Row[],\n): T[] => {\n  const result: T[] = []\n  const rows = rowColumns.map(row => row.values)\n  const headers = headerColumns.map(column => column.name)\n  rows.forEach((row, index) => {\n    result[index] = {} as T\n    row.forEach((text, cellIndex) => {\n      ;(result[index] as Record<string, unknown>)[headers[cellIndex]] = text\n    })\n  })\n  return result\n}\n"],"names":["WITHOUT_SYN_PREFIX","QUERY_FILTERS_LOCAL_STORAGE_KEY","key","removePrefixIfSynId","value","SYNAPSE_ENTITY_ID_REGEX","getAdditionalFilters","localStorageKey","searchParams","operator","ColumnSingleValueFilterOperator","localStorageQueryFiltersString","additionalFilters","isQueryWrapperKey","ColumnMultiValueFunction","param","parseEntityIdFromSqlStatement","sql","matches","parseEntityIdAndVersionFromSqlStatement","resultToJson","headerColumns","rowColumns","result","rows","row","headers","column","index","text","cellIndex"],"mappings":"4GAcA,MAAMA,EAAqB,EACdC,EAAmCC,GAC9C,GAAGA,CAAG,0BAED,SAASC,EAAoBC,EAAe,CAC7C,OAAAA,EAAM,MAAMC,CAAuB,EAC9BD,EAAM,UAAUJ,CAAkB,EAEpCI,CACT,CAgBO,MAAME,EAAuB,CAClCC,EACAC,EACAC,EAAwBC,EAAgC,OAC1B,CAC9B,MAAMC,EAAiC,aAAa,QAClDV,EAAgCM,CAAe,CAAA,EAEjD,IAAIK,EAAmC,CAAA,EAcvC,GAbID,IACFC,EAAoB,KAAK,MACvBD,CAAA,EAGF,WACE,IACE,aAAa,WACXV,EAAgCM,CAAe,CACjD,EACF,GAAA,GAGAC,EAAc,CACV,MAAAK,EAAqBX,GACzBA,EAAI,WAAW,cAAc,GAAKA,EAAI,WAAW,IAAI,EACvDU,EAAoBA,EAAkB,OACpC,OAAO,KAAKJ,GAAgB,CAAE,CAAA,EAC3B,OAAcN,GAAA,CAACW,EAAkBX,CAAG,CAAC,EACrC,IAAWA,GAAA,CACV,OAAQO,EAAU,CAChB,KAAKC,EAAgC,MAQ5B,MAPsC,CAC3C,aACE,oEACF,WAAYR,EACZ,SAAAO,EACA,OAAQ,CAACD,EAAaN,CAAG,CAAC,CAAA,EAI9B,KAAKQ,EAAgC,GAQ5B,MAPsC,CAC3C,aACE,oEACF,WAAYR,EACZ,SAAAO,EACA,OAAQD,EAAaN,CAAG,EAAE,MAAM,GAAG,CAAA,EAIvC,KAAKY,EAAyB,IAQrB,MAP6C,CAClD,aACE,2EACF,WAAYZ,EACZ,SAAUO,EACV,OAAQD,EAAaN,CAAG,EAAE,MAAM,GAAG,CAAA,EAIvC,KAAKQ,EAAgC,KAa5B,MARsC,CAC3C,aACE,oEACF,WAAYR,EACZ,SAAAO,EAEA,OAAQ,CAAC,IAAIN,EAAoBK,EAAaN,CAAG,CAAC,CAAC,GAAG,CAAA,EAI1D,KAAKY,EAAyB,SAWrB,MAV6C,CAClD,aACE,2EACF,WAAYZ,EACZ,SAAUO,EACV,OAAQD,EAAaN,CAAG,EAAE,MAAM,GAAG,EAAE,IAAaa,GAEzC,IAAIZ,EAAoBY,CAAK,CAAC,GACtC,CAAA,CAIP,CAAA,CACD,CAAA,CAEP,CAEO,OAAAH,EAAkB,SAAW,EAAI,OAAYA,CACtD,EAIaI,EAAiCC,GAAwB,CAC9D,MAAAC,EAAUD,EAAI,MAAM,qBAAqB,EACxC,OAAAC,GAAWA,EAAQ,CAAC,EAAIA,EAAQ,CAAC,EAAE,OAAO,CAAC,EAAE,KAAA,EAAS,EAC/D,EAEaC,EACXF,GACwD,CAElD,MAAAC,EADQ,+BACQ,KAAKD,CAAG,EAC9B,OAAKC,EAGE,CACL,SAAUA,EAAQ,CAAC,EACnB,cAAeA,EAAQ,CAAC,EAAI,SAASA,EAAQ,CAAC,CAAC,EAAI,MAAA,EAJ5C,IAMX,EAEaE,EAAe,CAC1BC,EACAC,IACQ,CACR,MAAMC,EAAc,CAAA,EACdC,EAAOF,EAAW,IAAIG,GAAOA,EAAI,MAAM,EACvCC,EAAUL,EAAc,IAAIM,GAAUA,EAAO,IAAI,EAClD,OAAAH,EAAA,QAAQ,CAACC,EAAKG,IAAU,CACpBL,EAAAK,CAAK,EAAI,GACZH,EAAA,QAAQ,CAACI,EAAMC,IAAc,CAC7BP,EAAOK,CAAK,EAA8BF,EAAQI,CAAS,CAAC,EAAID,CAAA,CACnE,CAAA,CACF,EACMN,CACT"}