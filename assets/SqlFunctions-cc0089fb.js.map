{"version":3,"file":"SqlFunctions-cc0089fb.js","sources":["../../src/utils/functions/SqlFunctions.ts"],"sourcesContent":["import { Row, SelectColumn } from '@sage-bionetworks/synapse-types'\nimport { SYNAPSE_ENTITY_ID_REGEX } from './RegularExpressions'\nimport {\n  ColumnMultiValueFunction,\n  ColumnMultiValueFunctionQueryFilter,\n  ColumnSingleValueFilterOperator,\n  ColumnSingleValueQueryFilter,\n  QueryFilter,\n} from '@sage-bionetworks/synapse-types'\n\nexport type SQLOperator =\n  | ColumnSingleValueFilterOperator\n  | ColumnMultiValueFunction\n\nconst WITHOUT_SYN_PREFIX = 3\n\nfunction removePrefixIfSynId(value: string) {\n  if (value.match(SYNAPSE_ENTITY_ID_REGEX)) {\n    return value.substring(WITHOUT_SYN_PREFIX)\n  }\n  return value\n}\nexport const getIgnoredQueryFilterSearchParamKey = (\n  key: string,\n  namespace?: string,\n) => {\n  return `__${namespace ?? ''}_${key}`\n}\n/**\n * Given the search params, return a set of QueryFilters to narrow the the query to view just related data. May return null if a QueryFilter should not be added.\n * @param sql\n * @param searchParams\n * @param operator\n * @returns\n */\nexport const generateQueryFilterFromSearchParams = (\n  searchParams?: Record<string, string>,\n  operator: SQLOperator = ColumnSingleValueFilterOperator.LIKE,\n): QueryFilter[] | undefined => {\n  if (!searchParams) {\n    return\n  }\n  const isQueryWrapperKey = (key: string) =>\n    key.startsWith('QueryWrapper') || key.startsWith('__')\n  const searchParamKeys = Object.keys(searchParams)\n  if (\n    searchParamKeys.length === 0 ||\n    searchParamKeys.every(isQueryWrapperKey)\n  ) {\n    return\n  }\n\n  return Object.keys(searchParams)\n    .filter(key => !isQueryWrapperKey(key))\n    .map(key => {\n      switch (operator) {\n        case ColumnSingleValueFilterOperator.EQUAL: {\n          const filter: ColumnSingleValueQueryFilter = {\n            concreteType:\n              'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n            columnName: key,\n            operator: operator,\n            values: [searchParams[key]],\n          }\n          return filter\n        }\n        case ColumnSingleValueFilterOperator.IN: {\n          const filter: ColumnSingleValueQueryFilter = {\n            concreteType:\n              'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n            columnName: key,\n            operator: operator,\n            values: searchParams[key].split(','),\n          }\n          return filter\n        }\n        case ColumnMultiValueFunction.HAS: {\n          const filter: ColumnMultiValueFunctionQueryFilter = {\n            concreteType:\n              'org.sagebionetworks.repo.model.table.ColumnMultiValueFunctionQueryFilter',\n            columnName: key,\n            function: operator,\n            values: searchParams[key].split(','),\n          }\n          return filter\n        }\n        case ColumnSingleValueFilterOperator.LIKE: {\n          // If we use a LIKE statement with a synId the backend will look for a string with the first three\n          // characters being 'syn', however, it stores synIds without 'syn', so the query will fail\n          // The backend usually parses 'syn' out, but not with the LIKE clause since its expecting a regex, so we\n          // parse this out. This will cause a bug if something matches the synId regex but is in free text.\n          const filter: ColumnSingleValueQueryFilter = {\n            concreteType:\n              'org.sagebionetworks.repo.model.table.ColumnSingleValueQueryFilter',\n            columnName: key,\n            operator: operator,\n            // Add wildcards around the value\n            values: [`%${removePrefixIfSynId(searchParams[key])}%`],\n          }\n          return filter\n        }\n        case ColumnMultiValueFunction.HAS_LIKE: {\n          const filter: ColumnMultiValueFunctionQueryFilter = {\n            concreteType:\n              'org.sagebionetworks.repo.model.table.ColumnMultiValueFunctionQueryFilter',\n            columnName: key,\n            function: operator,\n            values: searchParams[key].split(',').map(param => {\n              // Remove synId prefix for the same reasons as in the LIKE case\n              return `%${removePrefixIfSynId(param)}%`\n            }),\n          }\n          return filter\n        }\n      }\n    })\n}\n\n//parses synapse entity id from a sql query string\n//look for a pattern of 'from[some number of spaces]syn[somenumbers]` case insensitive\nexport const parseEntityIdFromSqlStatement = (sql: string): string => {\n  const matches = sql.match(/(from)\\s+(syn)\\d+/gi)\n  return matches && matches[0] ? matches[0].substr(5).trim() : ''\n}\n\nexport const parseEntityIdAndVersionFromSqlStatement = (\n  sql: string,\n): { entityId: string; versionNumber?: number } | null => {\n  const regex = /from\\s+(syn\\d+)(?:\\.(\\d+))?/i\n  const matches = regex.exec(sql)\n  if (!matches) {\n    return null\n  }\n  return {\n    entityId: matches[1],\n    versionNumber: matches[2] ? parseInt(matches[2]) : undefined,\n  }\n}\n\nexport const resultToJson = <T>(\n  headerColumns: SelectColumn[],\n  rowColumns: Row[],\n): T[] => {\n  const result: T[] = []\n  const rows = rowColumns.map(row => row.values)\n  const headers = headerColumns.map(column => column.name)\n  rows.forEach((row, index) => {\n    result[index] = {} as T\n    row.forEach((text, cellIndex) => {\n      ;(result[index] as Record<string, unknown>)[headers[cellIndex]] = text\n    })\n  })\n  return result\n}\n"],"names":["WITHOUT_SYN_PREFIX","removePrefixIfSynId","value","SYNAPSE_ENTITY_ID_REGEX","generateQueryFilterFromSearchParams","searchParams","operator","ColumnSingleValueFilterOperator","isQueryWrapperKey","key","searchParamKeys","ColumnMultiValueFunction","param","parseEntityIdFromSqlStatement","sql","matches","parseEntityIdAndVersionFromSqlStatement","resultToJson","headerColumns","rowColumns","result","rows","row","headers","column","index","text","cellIndex"],"mappings":"8GAcA,MAAMA,EAAqB,EAE3B,SAASC,EAAoBC,EAAe,CACtC,OAAAA,EAAM,MAAMC,CAAuB,EAC9BD,EAAM,UAAUF,CAAkB,EAEpCE,CACT,CAcO,MAAME,EAAsC,CACjDC,EACAC,EAAwBC,EAAgC,OAC1B,CAC9B,GAAI,CAACF,EACH,OAEI,MAAAG,EAAqBC,GACzBA,EAAI,WAAW,cAAc,GAAKA,EAAI,WAAW,IAAI,EACjDC,EAAkB,OAAO,KAAKL,CAAY,EAChD,GACE,EAAAK,EAAgB,SAAW,GAC3BA,EAAgB,MAAMF,CAAiB,GAKzC,OAAO,OAAO,KAAKH,CAAY,EAC5B,OAAOI,GAAO,CAACD,EAAkBC,CAAG,CAAC,EACrC,IAAWA,GAAA,CACV,OAAQH,EAAU,CAChB,KAAKC,EAAgC,MAQ5B,MAPsC,CAC3C,aACE,oEACF,WAAYE,EACZ,SAAAH,EACA,OAAQ,CAACD,EAAaI,CAAG,CAAC,CAAA,EAI9B,KAAKF,EAAgC,GAQ5B,MAPsC,CAC3C,aACE,oEACF,WAAYE,EACZ,SAAAH,EACA,OAAQD,EAAaI,CAAG,EAAE,MAAM,GAAG,CAAA,EAIvC,KAAKE,EAAyB,IAQrB,MAP6C,CAClD,aACE,2EACF,WAAYF,EACZ,SAAUH,EACV,OAAQD,EAAaI,CAAG,EAAE,MAAM,GAAG,CAAA,EAIvC,KAAKF,EAAgC,KAa5B,MARsC,CAC3C,aACE,oEACF,WAAYE,EACZ,SAAAH,EAEA,OAAQ,CAAC,IAAIL,EAAoBI,EAAaI,CAAG,CAAC,IAAI,CAAA,EAI1D,KAAKE,EAAyB,SAWrB,MAV6C,CAClD,aACE,2EACF,WAAYF,EACZ,SAAUH,EACV,OAAQD,EAAaI,CAAG,EAAE,MAAM,GAAG,EAAE,IAAaG,GAEzC,IAAIX,EAAoBW,CAAK,IACrC,CAAA,CAIP,CAAA,CACD,CACL,EAIaC,EAAiCC,GAAwB,CAC9D,MAAAC,EAAUD,EAAI,MAAM,qBAAqB,EACxC,OAAAC,GAAWA,EAAQ,CAAC,EAAIA,EAAQ,CAAC,EAAE,OAAO,CAAC,EAAE,KAAA,EAAS,EAC/D,EAEaC,EACXF,GACwD,CAElD,MAAAC,EADQ,+BACQ,KAAKD,CAAG,EAC9B,OAAKC,EAGE,CACL,SAAUA,EAAQ,CAAC,EACnB,cAAeA,EAAQ,CAAC,EAAI,SAASA,EAAQ,CAAC,CAAC,EAAI,MAAA,EAJ5C,IAMX,EAEaE,EAAe,CAC1BC,EACAC,IACQ,CACR,MAAMC,EAAc,CAAA,EACdC,EAAOF,EAAW,IAAIG,GAAOA,EAAI,MAAM,EACvCC,EAAUL,EAAc,IAAIM,GAAUA,EAAO,IAAI,EAClD,OAAAH,EAAA,QAAQ,CAACC,EAAKG,IAAU,CACpBL,EAAAK,CAAK,EAAI,GACZH,EAAA,QAAQ,CAACI,EAAMC,IAAc,CAC7BP,EAAOK,CAAK,EAA8BF,EAAQI,CAAS,CAAC,EAAID,CAAA,CACnE,CAAA,CACF,EACMN,CACT"}