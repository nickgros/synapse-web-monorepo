{"version":3,"file":"RenderIfInView-72581fed.js","sources":["../../src/components/utils/VisibilityObserver.tsx","../../src/components/RenderIfInView/RenderIfInView.tsx"],"sourcesContent":["/** Originally from YamUI.  May need to alter to update to later versions of react-intersection-observer (which does the heavy lifting).\n * This component has the option to provide an outOfView renderer, which might be useful in the future.\n */\nimport React from 'react'\nimport { InView } from 'react-intersection-observer'\n\nexport interface BaseComponentProps {\n  /**\n   * One or more class names to be added to the root element of this component, i.e.\n   * `\"class-one class-two\"`.\n   */\n  className?: string\n}\n\nexport interface NestableBaseComponentProps extends BaseComponentProps {\n  /**\n   * Elements to be rendered as children of this component.\n   */\n  children?: React.ReactNode\n}\n\nexport interface VisibilityObserverProps extends BaseComponentProps {\n  /**\n   * A callback which will be triggered when the component is scrolled into view.\n   */\n  onEnterView?: () => void\n\n  /**\n   * A callback which will be triggered when the component is scrolled out of view.\n   */\n  onLeaveView?: () => void\n\n  /**\n   * Render prop to return child content when the component is visible in the viewport. Once the component\n   * has been in view it will always use this render prop, even when scrolled back out of view.\n   */\n  renderInView?: () => React.ReactNode\n\n  /**\n   * Render prop to return child content before the component becomes visible in the viewport.\n   */\n  renderOutOfView?: () => React.ReactNode\n\n  /**\n   * Wrapper element tag name.\n   * @default 'div'\n   */\n  tag?: string\n\n  /**\n   * A CSS margin string which pushes the intersection boundary further in or out of the viewport.\n   * A positive value will expand the viewport threshold so your component is considered \"in view\" while it's\n   * still offscreen, for example you could set thresholdOffset=\"200px\" you want an image to start loading before\n   * it scrolls into view. A negative value will move the boundary into the viewport, triggering \"in view\" after\n   * it's already becoming visible.\n   * \"200px\", \"200px 0 50px 0\", \"-50px\" are all valid values.\n   */\n  rootMargin?: string\n}\n\nexport interface VisibilityObserverState {\n  hasBeenInView: boolean\n}\n\n/**\n * VisibilityObserver uses the IntersectionObserver API to allow conditional child rendering and callbacks based\n * on viewport visibility. It will render the `renderOutOfView` prop until it is scrolled into view, then will\n * always render the `renderInView` prop instead. Callbacks will always be triggered on visibility changes.\n */\nexport default class VisibilityObserver extends React.Component<\n  VisibilityObserverProps,\n  VisibilityObserverState\n> {\n  constructor(props: VisibilityObserverProps) {\n    super(props)\n    this.state = {\n      hasBeenInView: false,\n    }\n  }\n\n  public render() {\n    const { rootMargin, tag } = this.props\n\n    return (\n      <InView\n        as={(tag as any) || 'div'}\n        rootMargin={rootMargin}\n        onChange={this.onVisibilityChange}\n      >\n        {this.getObserverChildren}\n      </InView>\n    )\n  }\n\n  private getObserverChildren = (renderProps: {\n    inView: boolean\n    entry: IntersectionObserverEntry | undefined\n    ref: React.RefObject<any> | ((node?: Element | null) => void)\n  }) => {\n    const { renderInView, renderOutOfView } = this.props\n    const shouldRenderAsInView = renderProps.inView || this.state.hasBeenInView\n\n    if (shouldRenderAsInView && renderInView) {\n      return renderInView()\n    }\n\n    if (!renderProps.inView && renderOutOfView) {\n      return renderOutOfView()\n    }\n\n    return null\n  }\n\n  private onVisibilityChange = (isVisible: boolean) => {\n    if (isVisible) {\n      this.setState({ hasBeenInView: true })\n      if (this.props.onEnterView) {\n        this.props.onEnterView()\n      }\n    } else {\n      if (this.props.onLeaveView) {\n        this.props.onLeaveView()\n      }\n    }\n  }\n}\n","import React from 'react'\nimport VisibilityObserver from '../utils/VisibilityObserver'\n\nexport class RenderIfInView extends React.Component<\n  React.PropsWithChildren<unknown>\n> {\n  public render() {\n    return <VisibilityObserver renderInView={this.getChildren} />\n  }\n\n  private getChildren = () => {\n    return <>{this.props.children}</>\n  }\n}\n\nexport default RenderIfInView\n"],"names":["VisibilityObserver","React","props","__publicField","renderProps","renderInView","renderOutOfView","isVisible","rootMargin","tag","jsx","InView","RenderIfInView","Fragment"],"mappings":"0UAqEA,MAAAA,UAAAC,EAAA,SAAA,CAGE,YAAAC,EAAA,CAEE,MAAAA,CAAA,EAkBFC,EAAA,2BAAAC,GAAA,CAOE,KAAA,CAAA,aAAAC,EAAA,gBAAAC,GAAA,KAAA,MAGA,OAFAF,EAAA,QAAA,KAAA,MAAA,gBAEAC,EACEA,EAAA,EAGF,CAAAD,EAAA,QAAAE,EACEA,EAAA,EAGF,IAAO,GACTH,EAAA,0BAAAI,GAAA,CAGEA,GACE,KAAA,SAAA,CAAA,cAAA,EAAA,CAAA,EACA,KAAA,MAAA,aACE,KAAA,MAAA,eAGF,KAAA,MAAA,aACE,KAAA,MAAA,aAEJ,GAhDA,KAAA,MAAA,CAAa,cAAA,EACI,CACjB,CACF,QAAA,CAGE,KAAA,CAAA,WAAAC,EAAA,IAAAC,GAAA,KAAA,MAEA,OAAAC,EACEC,EAAC,CAAA,GAAAF,GAAA,MACqB,WAAAD,EACpB,SAAA,KAAA,mBACe,SAAA,KAAA,mBAET,CAAA,CACR,CAmCN;;;;;;+TC1HO,MAAAI,UAAAX,EAAA,SAAA,CAAA,kCAKLE,EAAA,mBAAA,IAGEO,EAAAG,EAAA,CAAA,SAAA,KAAA,MAAA,QAAA,CAAA,GANF,QAAA,CAEE,OAAAH,EAAAV,EAAA,CAAA,aAAA,KAAA,WAAA,CAAA,CAA2D,CAM/D"}