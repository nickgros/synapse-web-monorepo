{"version":3,"file":"useGetQueryResultBundle-d8d5d7d9.js","sources":["../../src/synapse-queries/entity/useGetQueryResultBundle.ts"],"sourcesContent":["import { merge } from 'lodash-es'\nimport { useMemo } from 'react'\nimport {\n  QueryFunctionContext,\n  QueryKey,\n  useInfiniteQuery,\n  UseInfiniteQueryOptions,\n  useQuery,\n  UseQueryOptions,\n  UseQueryResult,\n} from 'react-query'\nimport SynapseClient from '../../synapse-client'\nimport { SynapseClientError } from '../../utils/SynapseClientError'\nimport {\n  BUNDLE_MASK_QUERY_RESULTS,\n  DEFAULT_PAGE_SIZE,\n} from '../../utils/SynapseConstants'\nimport { useSynapseContext } from '../../utils/context/SynapseContext'\nimport {\n  AsynchronousJobStatus,\n  QueryBundleRequest,\n  QueryResultBundle,\n} from '@sage-bionetworks/synapse-types'\n\nconst sharedQueryDefaults = {\n  staleTime: 1000 * 60 * 30, // 30 minutes\n}\n\n/**\n *\n * @param queryBundleRequest\n * @param options\n * @returns\n *\n * @deprecated - use useGetQueryResultBundleWithAsyncStatus. That hook can be renamed and this can be removed\n *  when all cases are using useGetQueryResultBundleWithAsyncStatus\n */\nexport default function useGetQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<QueryResultBundle, SynapseClientError>,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  return useQuery<QueryResultBundle, SynapseClientError>(\n    keyFactory.getEntityTableQueryResultQueryKey(queryBundleRequest, false),\n    () => SynapseClient.getQueryTableResults(queryBundleRequest, accessToken),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n\nfunction _useGetQueryResultBundleWithAsyncStatus(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    keyFactory.getEntityTableQueryResultWithAsyncStatusQueryKey(\n      queryBundleRequest,\n      false,\n    ),\n    () =>\n      SynapseClient.getQueryTableAsyncJobResults(\n        queryBundleRequest,\n        accessToken,\n        setCurrentAsyncStatus,\n      ),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n\nfunction useGetQueryRows(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  // Get the request for just the rows\n  const queryRowsBundleRequestMask =\n    queryBundleRequest.partMask & BUNDLE_MASK_QUERY_RESULTS\n  const rowsOnlyQueryBundleRequest: QueryBundleRequest = {\n    ...queryBundleRequest,\n    partMask: queryRowsBundleRequestMask,\n  }\n\n  const enableQuery = queryRowsBundleRequestMask > 0 ? options?.enabled : false\n\n  return _useGetQueryResultBundleWithAsyncStatus(\n    rowsOnlyQueryBundleRequest,\n    {\n      ...options,\n      enabled: enableQuery,\n    },\n    setCurrentAsyncStatus,\n  )\n}\n\nfunction useGetQueryStats(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  // Bitwise remove the query result flag from the mask\n  const queryStatsMask =\n    queryBundleRequest.partMask & ~BUNDLE_MASK_QUERY_RESULTS\n  const queryStatsRequest: QueryBundleRequest = {\n    ...queryBundleRequest,\n    query: {\n      ...queryBundleRequest.query,\n      // Remove query fields that don't affect the results.\n      offset: undefined,\n      limit: undefined,\n      sort: undefined,\n    },\n    partMask: queryStatsMask,\n  }\n\n  const enableQuery = queryStatsMask > 0 ? options?.enabled : false\n\n  return _useGetQueryResultBundleWithAsyncStatus(\n    queryStatsRequest,\n    {\n      ...options,\n      enabled: enableQuery,\n    },\n    setCurrentAsyncStatus,\n  )\n}\n\nexport function useGetQueryResultBundleWithAsyncStatus(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  /**\n   * Separate the query into two parts\n   *  - Query result rows, which will change each page\n   *  - Everything else, which does not change each page\n   */\n  const rowResult = useGetQueryRows(\n    queryBundleRequest,\n    options,\n    setCurrentAsyncStatus,\n  )\n  const statsResult = useGetQueryStats(\n    queryBundleRequest,\n    options,\n    setCurrentAsyncStatus,\n  )\n\n  const mergedBundle = useMemo(() => {\n    // If either query is in error, return the error\n    if (rowResult.status === 'error') {\n      return rowResult\n    } else if (statsResult.status === 'error') {\n      return statsResult\n    } else if (rowResult.status === 'loading') {\n      // if either query is loading, return the loading status\n      return rowResult\n    } else if (statsResult.status === 'loading') {\n      return statsResult\n    } else {\n      // Otherwise, both queries are successful or idle, Merge the results into a single object\n      if (rowResult.status === 'idle') {\n        // If the row result is idle, apply the stats result last to override the idle status\n        return merge({}, rowResult, statsResult)\n      } else {\n        // Otherwise, always apply the rowResult last, since it is likely have been fetched more recently than the stats.\n        return merge({}, statsResult, rowResult)\n      }\n    }\n  }, [rowResult, statsResult])\n\n  return mergedBundle\n}\nexport function useInfiniteQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseInfiniteQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  return useInfiniteQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    keyFactory.getEntityTableQueryResultQueryKey(queryBundleRequest, true),\n    (context: QueryFunctionContext<QueryKey, string>) => {\n      const offset = context.pageParam ? parseInt(context.pageParam) : 0\n      return SynapseClient.getQueryTableAsyncJobResults(\n        {\n          ...queryBundleRequest,\n          query: {\n            ...queryBundleRequest.query,\n            offset: offset,\n          },\n          /**\n           * If we're on the first page, send the original partMask.\n           * Otherwise, just ask for the queryResults (if they're in the original partMask), as it's the only part that changes between pages.\n           *\n           * We'll merge the \"aggregation\" parts and the pages of queryResults in the `select` function.\n           */\n          partMask:\n            offset !== 0\n              ? queryBundleRequest.partMask & BUNDLE_MASK_QUERY_RESULTS\n              : queryBundleRequest.partMask,\n        },\n        accessToken,\n        setCurrentAsyncStatus,\n      )\n    },\n    {\n      ...sharedQueryDefaults,\n      ...options,\n      select: data => {\n        /**\n         * Since we we only fetch queryResults on 2nd and subsequent pages, we add to all pages the aggregate parts\n         * that we only fetched on the first page.\n         */\n        const firstPage = data?.pages[0]\n        if (firstPage.responseBody) {\n          for (let i = 0; i < data.pages.length; i++) {\n            const page = data.pages[i]\n            if (page.responseBody != null) {\n              data.pages[i].responseBody = {\n                ...firstPage.responseBody,\n                // queryResult changes on each page.\n                queryResult: page.responseBody.queryResult,\n              }\n            }\n          }\n        }\n        return data\n      },\n      getPreviousPageParam: firstPage => {\n        if (firstPage.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = firstPage.requestBody\n        if (request.query.offset == null || request.query.offset === 0) {\n          return undefined\n        }\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n\n        return Math.max(request.query.offset - pageSize, 0)\n      },\n      getNextPageParam: (page, allPages) => {\n        if (page.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = page.requestBody\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n        const totalQueryResultCount = allPages[0].responseBody?.queryCount\n        if (totalQueryResultCount != null) {\n          // We know the total number of results. See if our offset + pageSize is >= the total\n          if ((request.query.offset ?? 0) + pageSize >= totalQueryResultCount) {\n            return undefined\n          }\n        }\n        return page.responseBody!.queryResult?.queryResults.rows.length ===\n          pageSize\n          ? (request.query.offset ?? 0) + pageSize\n          : undefined\n      },\n    },\n  )\n}\n\n/**\n * Fetches all rows for a table query. Only use this request if you require all rows in a table at once.\n */\nexport function useGetFullTableQueryResults(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<QueryResultBundle, SynapseClientError>,\n): UseQueryResult<QueryResultBundle, SynapseClientError> {\n  const { accessToken, keyFactory } = useSynapseContext()\n  return useQuery<QueryResultBundle, SynapseClientError>(\n    keyFactory.getFullTableQueryResultQueryKey(queryBundleRequest),\n    () =>\n      SynapseClient.getFullQueryTableResults(queryBundleRequest, accessToken),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n"],"names":["sharedQueryDefaults","useGetQueryResultBundle","queryBundleRequest","options","accessToken","keyFactory","useSynapseContext","useQuery","SynapseClient","_useGetQueryResultBundleWithAsyncStatus","setCurrentAsyncStatus","useGetQueryRows","queryRowsBundleRequestMask","BUNDLE_MASK_QUERY_RESULTS","rowsOnlyQueryBundleRequest","enableQuery","useGetQueryStats","queryStatsMask","queryStatsRequest","useGetQueryResultBundleWithAsyncStatus","rowResult","statsResult","useMemo","merge","useInfiniteQueryResultBundle","useInfiniteQuery","context","offset","data","firstPage","i","page","request","pageSize","DEFAULT_PAGE_SIZE","allPages","totalQueryResultCount","_a","_b","useGetFullTableQueryResults"],"mappings":"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"}