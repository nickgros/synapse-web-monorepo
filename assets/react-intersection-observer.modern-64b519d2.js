import{r as a}from"./index-8db94870.js";function w(){return w=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},w.apply(this,arguments)}function x(e,t){if(e==null)return{};var n={},s=Object.keys(e),r,i;for(i=0;i<s.length;i++)r=s[i],!(t.indexOf(r)>=0)&&(n[r]=e[r]);return n}const C=new Map,b=new WeakMap;let m=0,M;function E(e){return e?(b.has(e)||(m+=1,b.set(e,m.toString())),b.get(e)):"0"}function N(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?E(e.root):e[t]}`).toString()}function j(e){let t=N(e),n=C.get(t);if(!n){const s=new Map;let r;const i=new IntersectionObserver(o=>{o.forEach(u=>{var h;const p=u.isIntersecting&&r.some(c=>u.intersectionRatio>=c);e.trackVisibility&&typeof u.isVisible>"u"&&(u.isVisible=p),(h=s.get(u.target))==null||h.forEach(c=>{c(p,u)})})},e);r=i.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:i,elements:s},C.set(t,n)}return n}function R(e,t,n={},s=M){if(typeof window.IntersectionObserver>"u"&&s!==void 0){const h=e.getBoundingClientRect();return t(s,{isIntersecting:s,target:e,intersectionRatio:typeof n.threshold=="number"?n.threshold:0,time:0,boundingClientRect:h,intersectionRect:h,rootBounds:h}),()=>{}}const{id:r,observer:i,elements:o}=j(n);let u=o.get(e)||[];return o.has(e)||o.set(e,u),u.push(t),i.observe(e),function(){u.splice(u.indexOf(t),1),u.length===0&&(o.delete(e),i.unobserve(e)),o.size===0&&(i.disconnect(),C.delete(r))}}const k=["children","as","triggerOnce","threshold","root","rootMargin","onChange","skip","trackVisibility","delay","initialInView","fallbackInView"];function O(e){return typeof e.children!="function"}class A extends a.Component{constructor(t){super(t),this.node=null,this._unobserveCb=null,this.handleNode=n=>{this.node&&(this.unobserve(),!n&&!this.props.triggerOnce&&!this.props.skip&&this.setState({inView:!!this.props.initialInView,entry:void 0})),this.node=n||null,this.observeNode()},this.handleChange=(n,s)=>{n&&this.props.triggerOnce&&this.unobserve(),O(this.props)||this.setState({inView:n,entry:s}),this.props.onChange&&this.props.onChange(n,s)},this.state={inView:!!t.initialInView,entry:void 0}}componentDidUpdate(t){(t.rootMargin!==this.props.rootMargin||t.root!==this.props.root||t.threshold!==this.props.threshold||t.skip!==this.props.skip||t.trackVisibility!==this.props.trackVisibility||t.delay!==this.props.delay)&&(this.unobserve(),this.observeNode())}componentWillUnmount(){this.unobserve(),this.node=null}observeNode(){if(!this.node||this.props.skip)return;const{threshold:t,root:n,rootMargin:s,trackVisibility:r,delay:i,fallbackInView:o}=this.props;this._unobserveCb=R(this.node,this.handleChange,{threshold:t,root:n,rootMargin:s,trackVisibility:r,delay:i},o)}unobserve(){this._unobserveCb&&(this._unobserveCb(),this._unobserveCb=null)}render(){if(!O(this.props)){const{inView:i,entry:o}=this.state;return this.props.children({inView:i,entry:o,ref:this.handleNode})}const t=this.props,{children:n,as:s}=t,r=x(t,k);return a.createElement(s||"div",w({ref:this.handleNode},r),n)}}function W({threshold:e,delay:t,trackVisibility:n,rootMargin:s,root:r,triggerOnce:i,skip:o,initialInView:u,fallbackInView:h,onChange:p}={}){var c;const[l,S]=a.useState(null),g=a.useRef(),[v,V]=a.useState({inView:!!u,entry:void 0});g.current=p,a.useEffect(()=>{if(o||!l)return;let f;return f=R(l,(_,y)=>{V({inView:_,entry:y}),g.current&&g.current(_,y),y.isIntersecting&&i&&f&&(f(),f=void 0)},{root:r,rootMargin:s,threshold:e,trackVisibility:n,delay:t},h),()=>{f&&f()}},[Array.isArray(e)?e.toString():e,l,r,s,i,o,n,h,t]);const I=(c=v.entry)==null?void 0:c.target;a.useEffect(()=>{!l&&I&&!i&&!o&&V({inView:!!u,entry:void 0})},[l,I,i,o,u]);const d=[S,v.inView,v.entry];return d.ref=d[0],d.inView=d[1],d.entry=d[2],d}export{A as I,W as u};
//# sourceMappingURL=react-intersection-observer.modern-64b519d2.js.map
