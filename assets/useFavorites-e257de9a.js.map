{"version":3,"file":"useFavorites-e257de9a.js","sources":["../../src/lib/utils/hooks/SynapseAPI/user/useFavorites.ts"],"sourcesContent":["import {\n  UseInfiniteQueryOptions,\n  useQuery,\n  UseQueryOptions,\n  useInfiniteQuery,\n  useMutation,\n  useQueryClient,\n  UseMutationOptions,\n} from 'react-query'\nimport { SynapseClient } from '../../..'\nimport { SynapseClientError } from '../../../SynapseClientError'\nimport { useSynapseContext } from '../../../SynapseContext'\nimport { EntityHeader, PaginatedResults } from '../../../synapseTypes'\nimport {\n  FavoriteSortBy,\n  FavoriteSortDirection,\n} from '../../../synapseTypes/FavoriteSortBy'\n\nexport function useIsFavorite(entityId: string) {\n  // TODO: Handle pagination - the default limit is 200\n  // It would probably make more sense to add a backend service to check if an entity ID is favorited\n  const { data: allFavorites, isLoading } = useGetFavorites()\n  const isFavorite = allFavorites?.results?.some(\n    favorite => favorite.id === entityId,\n  )\n  return { isFavorite, isLoading }\n}\n\nexport function useAddFavorite(\n  options?: UseMutationOptions<EntityHeader, SynapseClientError, string>,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  const queryClient = useQueryClient()\n  return useMutation({\n    ...options,\n    mutationFn: (entityId: string) =>\n      SynapseClient.addUserFavorite(entityId, accessToken),\n    mutationKey: ['addFavorite'],\n    onSuccess: async (data, variables, ctx) => {\n      await queryClient.invalidateQueries(keyFactory.getFavoritesQueryKey())\n      if (options?.onSuccess) {\n        return options.onSuccess(data, variables, ctx)\n      }\n    },\n  })\n}\n\nexport function useRemoveFavorite(\n  options?: UseMutationOptions<void, SynapseClientError, string>,\n) {\n  const { accessToken } = useSynapseContext()\n  const queryClient = useQueryClient()\n  const { keyFactory } = useSynapseContext()\n\n  return useMutation({\n    ...options,\n    mutationFn: (entityId: string) =>\n      SynapseClient.removeUserFavorite(entityId, accessToken),\n    mutationKey: ['removeFavorite'],\n    onSuccess: async (data, variables, ctx) => {\n      await queryClient.invalidateQueries(keyFactory.getFavoritesQueryKey())\n      if (options?.onSuccess) {\n        return options.onSuccess(data, variables, ctx)\n      }\n    },\n  })\n}\n\nexport function useGetFavorites(\n  sort: FavoriteSortBy = 'FAVORITED_ON',\n  sortDirection: FavoriteSortDirection = 'DESC',\n  options?: UseQueryOptions<\n    PaginatedResults<EntityHeader>,\n    SynapseClientError,\n    PaginatedResults<EntityHeader>\n  >,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useQuery<PaginatedResults<EntityHeader>, SynapseClientError>(\n    keyFactory.getUserFavoritesQueryKey(sort, sortDirection),\n    () =>\n      SynapseClient.getUserFavorites(\n        accessToken,\n        undefined,\n        undefined,\n        sort,\n        sortDirection,\n      ),\n    options,\n  )\n}\n\nexport function useGetFavoritesInfinite(\n  sort: FavoriteSortBy = 'FAVORITED_ON',\n  sortDirection: FavoriteSortDirection = 'DESC',\n  options?: UseInfiniteQueryOptions<\n    PaginatedResults<EntityHeader>,\n    SynapseClientError\n  >,\n) {\n  const LIMIT = 10\n\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useInfiniteQuery<PaginatedResults<EntityHeader>, SynapseClientError>(\n    keyFactory.getUserFavoritesInfiniteQueryKey(sort, sortDirection),\n    async context => {\n      return SynapseClient.getUserFavorites(\n        accessToken,\n        // pass the context.pageParam for the new offset\n        context.pageParam,\n        LIMIT,\n        sort,\n        sortDirection,\n      )\n    },\n    {\n      ...options,\n      getNextPageParam: (lastPage, pages) => {\n        if (lastPage.results.length > 0) return pages.length * LIMIT\n        //set the new offset to (page * limit)\n        else return undefined\n      },\n    },\n  )\n}\n"],"names":["useIsFavorite","entityId","allFavorites","isLoading","useGetFavorites","_a","favorite","useAddFavorite","options","accessToken","keyFactory","useSynapseContext","queryClient","useQueryClient","useMutation","SynapseClient.addUserFavorite","data","variables","ctx","useRemoveFavorite","SynapseClient.removeUserFavorite","sort","sortDirection","useQuery","SynapseClient.getUserFavorites","useGetFavoritesInfinite","useInfiniteQuery","context","lastPage","pages"],"mappings":"2RAkBO,SAASA,EAAcC,EAAkB,OAG9C,KAAM,CAAE,KAAMC,EAAc,UAAAC,GAAcC,EAAgB,EAInD,MAAA,CAAE,YAHUC,EAAAH,GAAA,YAAAA,EAAc,UAAd,YAAAG,EAAuB,KACxCC,GAAYA,EAAS,KAAOL,GAET,UAAAE,EACvB,CAEO,SAASI,EACdC,EACA,CACA,KAAM,CAAE,YAAAC,EAAa,WAAAC,CAAW,EAAIC,EAAkB,EAChDC,EAAcC,IACpB,OAAOC,EAAY,CACjB,GAAGN,EACH,WAAaP,GACXc,EAA8Bd,EAAUQ,CAAW,EACrD,YAAa,CAAC,aAAa,EAC3B,UAAW,MAAOO,EAAMC,EAAWC,IAAQ,CAEzC,GADA,MAAMN,EAAY,kBAAkBF,EAAW,qBAAsB,CAAA,EACjEF,GAAA,MAAAA,EAAS,UACX,OAAOA,EAAQ,UAAUQ,EAAMC,EAAWC,CAAG,CAEjD,CAAA,CACD,CACH,CAEO,SAASC,EACdX,EACA,CACM,KAAA,CAAE,YAAAC,GAAgBE,IAClBC,EAAcC,IACd,CAAE,WAAAH,GAAeC,IAEvB,OAAOG,EAAY,CACjB,GAAGN,EACH,WAAaP,GACXmB,EAAiCnB,EAAUQ,CAAW,EACxD,YAAa,CAAC,gBAAgB,EAC9B,UAAW,MAAOO,EAAMC,EAAWC,IAAQ,CAEzC,GADA,MAAMN,EAAY,kBAAkBF,EAAW,qBAAsB,CAAA,EACjEF,GAAA,MAAAA,EAAS,UACX,OAAOA,EAAQ,UAAUQ,EAAMC,EAAWC,CAAG,CAEjD,CAAA,CACD,CACH,CAEO,SAASd,EACdiB,EAAuB,eACvBC,EAAuC,OACvCd,EAKA,CACA,KAAM,CAAE,YAAAC,EAAa,WAAAC,CAAW,EAAIC,EAAkB,EAE/C,OAAAY,EACLb,EAAW,yBAAyBW,EAAMC,CAAa,EACvD,IACEE,EACEf,EACA,OACA,OACAY,EACAC,CACF,EACFd,CAAA,CAEJ,CAEO,SAASiB,EACdJ,EAAuB,eACvBC,EAAuC,OACvCd,EAIA,CAGA,KAAM,CAAE,YAAAC,EAAa,WAAAC,CAAW,EAAIC,EAAkB,EAE/C,OAAAe,EACLhB,EAAW,iCAAiCW,EAAMC,CAAa,EAC/D,MAAMK,GACGH,EACLf,EAEAkB,EAAQ,UACR,GACAN,EACAC,CAAA,EAGJ,CACE,GAAGd,EACH,iBAAkB,CAACoB,EAAUC,IAAU,CACjC,GAAAD,EAAS,QAAQ,OAAS,EAAG,OAAOC,EAAM,OAAS,EAGzD,CACF,CAAA,CAEJ"}