{"version":3,"file":"useGetInfoFromIds-c6504d1e.js","sources":["../../src/lib/utils/hooks/useGetInfoFromIds.ts"],"sourcesContent":["import { chunk, uniq, without } from 'lodash-es'\nimport { useEffect, useState } from 'react'\nimport useDeepCompareEffect from 'use-deep-compare-effect'\nimport { SynapseConstants } from '..'\nimport {\n  getEntityHeaders,\n  getEvaluations,\n  getGroupHeadersBatch,\n} from '../SynapseClient'\nimport { useSynapseContext } from '../SynapseContext'\nimport {\n  EntityHeader,\n  Evaluation,\n  Reference,\n  ReferenceList,\n  UserGroupHeader,\n} from '../synapseTypes'\n\nexport type HookType = 'ENTITY_HEADER' | 'USER_PROFILE' | 'EVALUATION_QUEUE'\nexport type UseGetInfoFromIdsProps = {\n  ids: string[]\n  type: HookType\n}\n\ntype LookupRequestType = string | Reference\n\nconst UserGroupHeaderTemplate: UserGroupHeader = {\n  ownerId: '', // A foreign key to the ID of the 'principal' object for the user\n  firstName: 'Unknown', // This person's given name (forename)\n  lastName: 'Unknown', // This person's family name (surname)\n  userName: 'Unknown', // A name chosen by the user that uniquely identifies them\n  isIndividual: false,\n}\n\nconst entityHeaderTemplate: EntityHeader = {\n  name: 'Unknown', //\tThe name of the entity\n  id: 'unknown', //\tThe id of the entity\n  type: 'org.sagebionetworks.repo.model.FileEntity', //\tThe type of the entity\n  versionNumber: 0, //\tThe version number of the entity\n  versionLabel: 'placeholder', //\tThe user defined version label of the entity\n  benefactorId: 0, //\tThe ID of the entity that this Entity's ACL is inherited from.\n  createdOn: 'null', //\tThe date this entity was created.\n  modifiedOn: 'null', //\tThe date this entity was last modified.\n  createdBy: 'null', //\tThe ID of the user that created this entity.\n  modifiedBy: 'null', //\tThe ID of the user that last modified this entity.\n  isLatestVersion: true, // If this version is the latest version of the entity\n}\n\nconst evaluationTemplate: Evaluation = {\n  id: 'unknown', // The unique immutable ID for this Evaluation.\n  etag: 'Unknown', // Synapse employs an Optimistic Concurrency Control (OCC) scheme to handle concurrent updates. The eTag changes every time an Evaluation is updated; it is used to detect when a client's copy of an Evaluation is out-of-date.\n  name: 'Unknown', // The name of this Evaluation\n  description: 'Unknown', // A text description of this Evaluation.\n  ownerId: 'null', // The ID of the Synapse user who created this Evaluation.\n  createdOn: 'null', //\tThe date on which Evaluation was created.\n  contentSource: 'Unknown', // The Synapse ID of the Entity to which this Evaluation belongs, e.g. a reference to a Synapse project.\n  submissionInstructionsMessage: 'Unknown', // Message to display to users detailing acceptable formatting for Submissions to this Evaluation.\n  submissionReceiptMessage: 'Unknown', // Message to display to users upon successful submission to this Evaluation.\n}\n\nconst getEntityHeaderItems = async (\n  lookupList: ReferenceList,\n  token: string | undefined,\n): Promise<EntityHeader[]> => {\n  const newData = await getEntityHeaders(lookupList, token)\n  const notFound = lookupList.filter(\n    item => newData.results.map(item => item.id).indexOf(item.targetId) === -1,\n  )\n  const notFoundPlaceholders = notFound.map(item => ({\n    ...entityHeaderTemplate,\n    id: item.targetId,\n    name: `${item.targetId}`,\n  }))\n\n  return [...newData.results, ...notFoundPlaceholders]\n}\n\nconst getUserGroupHeaderItems = async (\n  lookupList: string[],\n): Promise<UserGroupHeader[]> => {\n  const newData = (await getGroupHeadersBatch(lookupList)).children\n  const notFound = lookupList.filter(\n    item => newData.map(item => item.ownerId).indexOf(item) === -1,\n  )\n  const notFoundPlaceholders = notFound.map(item => ({\n    ...UserGroupHeaderTemplate,\n    ownerId: item,\n    name: `Unknown User (${item})`,\n  }))\n\n  return [...newData, ...notFoundPlaceholders]\n}\n\nconst getEvaluationItems = async (\n  lookupList: string[],\n  token: string | undefined,\n): Promise<Evaluation[]> => {\n  const newData = await getEvaluations(lookupList, token)\n  const notFound = lookupList.filter(\n    item => newData.results.map(item => item.id).indexOf(item) === -1,\n  )\n  const notFoundPlaceholders = notFound.map(item => ({\n    ...evaluationTemplate,\n    id: item,\n    name: item,\n  }))\n\n  return [...newData.results, ...notFoundPlaceholders]\n}\n\n/**\n * React hook to get user profiles or entities or evaluation queues. Utilizes a custom cache in sessionStorage.\n *\n * For fetching just one entity or usergroup, see useGetEntity/useGetUserGroupHeader hooks powered by react-query\n * @returns\n */\nexport default function useGetInfoFromIds<\n  T extends EntityHeader | UserGroupHeader | Evaluation,\n>(props: UseGetInfoFromIdsProps): T[] {\n  const { ids, type } = props\n  const { accessToken } = useSynapseContext()\n\n  const [data, setData] = useState<Array<T>>([])\n\n  const idProp = (type: HookType) =>\n    type === 'USER_PROFILE' ? 'ownerId' : 'id'\n\n  const storageKey = (type: HookType) => {\n    switch (type) {\n      case 'USER_PROFILE':\n        return SynapseConstants.USER_PROFILE_STORAGE_KEY\n      case 'ENTITY_HEADER':\n        return SynapseConstants.ENTITY_HEADER_STORAGE_KEY\n      case 'EVALUATION_QUEUE':\n        return SynapseConstants.EVALUATIONS_STORAGE_KEY\n      default:\n        return ''\n    }\n  }\n\n  // look at current list of data, see if incoming ids has new data,\n  // if so grab those ids\n  const curList = data.map(el => el[idProp(type)])\n  const incomingList = ids.filter(el => el !== SynapseConstants.VALUE_NOT_SET)\n  const newValues = uniq(without(incomingList, ...curList))\n\n  useEffect(() => {\n    const saveToSessionStorage = (data: T[], type: HookType) => {\n      if (!data.length) {\n        return\n      }\n      //get what's there\n      const dataInStorage = sessionStorage.getItem(storageKey(type))\n      try {\n        const dataInStorageAsObjectArr: T[] = dataInStorage\n          ? JSON.parse(dataInStorage)\n          : []\n        //get an array of ids for items already in storage\n        const ids = dataInStorageAsObjectArr.map(item => item[idProp(type)])\n        //push all the new data if ids are new\n        for (const dataObject of data) {\n          if (!ids.includes(dataObject[idProp(type)])) {\n            dataInStorageAsObjectArr.push(dataObject)\n          }\n        }\n        sessionStorage.setItem(\n          storageKey(type),\n          JSON.stringify(dataInStorageAsObjectArr),\n        )\n      } catch (e) {\n        sessionStorage.setItem(storageKey(type), JSON.stringify(data))\n      }\n    }\n    saveToSessionStorage(data, type)\n  }, [data, type])\n\n  // Alina TODO: check if the items are already in Local Storage before making server call.\n\n  // Michael TODO: There's a bug where the data held in useGetInfoFromIds will be stale if the user token changes,\n  // this can be solved by using the useCompare hook on the token to track when it changes\n  useDeepCompareEffect(() => {\n    let isCancelled = false\n    const getData = async () => {\n      if (newValues.length > 0) {\n        try {\n          const newIds = Array.from<string>(newValues)\n          const newReferences: LookupRequestType[] =\n            type === 'ENTITY_HEADER'\n              ? newIds.map(el => ({ targetId: el }))\n              : newIds\n          const newReferencesChunks = chunk(newReferences, 45)\n          const totalData: T[] = []\n          for (const newReferences of newReferencesChunks) {\n            let newData = []\n            switch (type) {\n              case 'USER_PROFILE':\n                newData = await getUserGroupHeaderItems(\n                  newReferences as string[],\n                )\n                break\n              case 'ENTITY_HEADER':\n                newData = await getEntityHeaderItems(\n                  newReferences as ReferenceList,\n                  accessToken,\n                )\n                break\n              case 'EVALUATION_QUEUE':\n                newData = await getEvaluationItems(\n                  newReferences as string[],\n                  accessToken,\n                )\n                break\n            }\n            totalData.push(...(newData as T[]))\n          }\n          if (!isCancelled) {\n            setData(oldData => oldData.concat(...totalData))\n          }\n        } catch (error) {\n          console.error('Error on data retrieval', error)\n        }\n      }\n    }\n    getData()\n    return () => {\n      isCancelled = true\n    }\n  }, [accessToken, type, newValues])\n  return data\n}\n"],"names":["UserGroupHeaderTemplate","entityHeaderTemplate","evaluationTemplate","getEntityHeaderItems","lookupList","token","newData","getEntityHeaders","notFoundPlaceholders","item","getUserGroupHeaderItems","getGroupHeadersBatch","getEvaluationItems","getEvaluations","useGetInfoFromIds","props","ids","type","accessToken","useSynapseContext","data","setData","useState","idProp","storageKey","SynapseConstants.USER_PROFILE_STORAGE_KEY","SynapseConstants.ENTITY_HEADER_STORAGE_KEY","SynapseConstants.EVALUATIONS_STORAGE_KEY","curList","el","incomingList","SynapseConstants.VALUE_NOT_SET","newValues","uniq","without","useEffect","dataInStorage","dataInStorageAsObjectArr","dataObject","useDeepCompareEffect","isCancelled","newIds","newReferences","newReferencesChunks","chunk","totalData","oldData","error"],"mappings":"gVA0BA,MAAMA,EAA2C,CAC/C,QAAS,GACT,UAAW,UACX,SAAU,UACV,SAAU,UACV,aAAc,EAChB,EAEMC,EAAqC,CACzC,KAAM,UACN,GAAI,UACJ,KAAM,4CACN,cAAe,EACf,aAAc,cACd,aAAc,EACd,UAAW,OACX,WAAY,OACZ,UAAW,OACX,WAAY,OACZ,gBAAiB,EACnB,EAEMC,EAAiC,CACrC,GAAI,UACJ,KAAM,UACN,KAAM,UACN,YAAa,UACb,QAAS,OACT,UAAW,OACX,cAAe,UACf,8BAA+B,UAC/B,yBAA0B,SAC5B,EAEMC,EAAuB,MAC3BC,EACAC,IAC4B,CAC5B,MAAMC,EAAU,MAAMC,EAAiBH,EAAYC,CAAK,EAIlDG,EAHWJ,EAAW,OAClBK,GAAAH,EAAQ,QAAQ,IAAIG,GAAQA,EAAK,EAAE,EAAE,QAAQA,EAAK,QAAQ,IAAM,EAAA,EAEpC,IAAaA,IAAA,CACjD,GAAGR,EACH,GAAIQ,EAAK,SACT,KAAM,GAAGA,EAAK,UACd,EAAA,EAEF,MAAO,CAAC,GAAGH,EAAQ,QAAS,GAAGE,CAAoB,CACrD,EAEME,EAA0B,MAC9BN,GAC+B,CAC/B,MAAME,GAAW,MAAMK,EAAqBP,CAAU,GAAG,SAInDI,EAHWJ,EAAW,OAC1BK,GAAQH,EAAQ,IAAIG,GAAQA,EAAK,OAAO,EAAE,QAAQA,CAAI,IAAM,EAAA,EAExB,IAAaA,IAAA,CACjD,GAAGT,EACH,QAASS,EACT,KAAM,iBAAiBA,IACvB,EAAA,EAEF,MAAO,CAAC,GAAGH,EAAS,GAAGE,CAAoB,CAC7C,EAEMI,EAAqB,MACzBR,EACAC,IAC0B,CAC1B,MAAMC,EAAU,MAAMO,EAAeT,EAAYC,CAAK,EAIhDG,EAHWJ,EAAW,OAC1BK,GAAQH,EAAQ,QAAQ,IAAIG,GAAQA,EAAK,EAAE,EAAE,QAAQA,CAAI,IAAM,EAAA,EAE3B,IAAaA,IAAA,CACjD,GAAGP,EACH,GAAIO,EACJ,KAAMA,CACN,EAAA,EAEF,MAAO,CAAC,GAAGH,EAAQ,QAAS,GAAGE,CAAoB,CACrD,EAQA,SAAwBM,EAEtBC,EAAoC,CAC9B,KAAA,CAAE,IAAAC,EAAK,KAAAC,CAAS,EAAAF,EAChB,CAAE,YAAAG,GAAgBC,IAElB,CAACC,EAAMC,CAAO,EAAIC,EAAA,SAAmB,CAAE,CAAA,EAEvCC,EAAUN,GACdA,IAAS,eAAiB,UAAY,KAElCO,EAAcP,GAAmB,CACrC,OAAQA,EAAM,CACZ,IAAK,eACH,OAAOQ,EACT,IAAK,gBACH,OAAOC,EACT,IAAK,mBACH,OAAOC,EACT,QACS,MAAA,EACX,CAAA,EAKIC,EAAUR,EAAK,IAAIS,GAAMA,EAAGN,EAAON,CAAI,CAAC,CAAC,EACzCa,EAAed,EAAI,OAAaa,GAAAA,IAAOE,CAA8B,EACrEC,EAAYC,EAAKC,EAAQJ,EAAc,GAAGF,CAAO,CAAC,EAExDO,OAAAA,EAAAA,UAAU,IAAM,EACe,CAACf,EAAWH,IAAmB,CACtD,GAAA,CAACG,EAAK,OACR,OAGF,MAAMgB,EAAgB,eAAe,QAAQZ,EAAWP,CAAI,CAAC,EACzD,GAAA,CACF,MAAMoB,EAAgCD,EAClC,KAAK,MAAMA,CAAa,EACxB,GAEEpB,EAAMqB,EAAyB,IAAI5B,GAAQA,EAAKc,EAAON,CAAI,CAAC,CAAC,EAEnE,UAAWqB,KAAclB,EAClBJ,EAAI,SAASsB,EAAWf,EAAON,CAAI,CAAC,CAAC,GACxCoB,EAAyB,KAAKC,CAAU,EAG7B,eAAA,QACbd,EAAWP,CAAI,EACf,KAAK,UAAUoB,CAAwB,CAAA,QAGzC,eAAe,QAAQb,EAAWP,CAAI,EAAG,KAAK,UAAUG,CAAI,CAAC,CAC/D,CAAA,GAEmBA,EAAMH,CAAI,CAAA,EAC9B,CAACG,EAAMH,CAAI,CAAC,EAMfsB,EAAqB,IAAM,CACzB,IAAIC,EAAc,GA0CV,OAzCQ,SAAY,CACtB,GAAAR,EAAU,OAAS,EACjB,GAAA,CACI,MAAAS,EAAS,MAAM,KAAaT,CAAS,EACrCU,EACJzB,IAAS,gBACLwB,EAAO,QAAW,CAAE,SAAUZ,GAAK,EACnCY,EACAE,EAAsBC,EAAMF,EAAe,EAAE,EAC7CG,EAAiB,CAAA,EACvB,UAAWH,KAAiBC,EAAqB,CAC/C,IAAIrC,EAAU,CAAA,EACd,OAAQW,EAAM,CACZ,IAAK,eACHX,EAAU,MAAMI,EACdgC,CAAA,EAEF,MACF,IAAK,gBACHpC,EAAU,MAAMH,EACduC,EACAxB,CAAA,EAEF,MACF,IAAK,mBACHZ,EAAU,MAAMM,EACd8B,EACAxB,CAAA,EAEF,KACJ,CACU2B,EAAA,KAAK,GAAIvC,CAAe,CACpC,CACKkC,GACHnB,EAAmByB,GAAAA,EAAQ,OAAO,GAAGD,CAAS,CAAC,QAE1CE,GACC,QAAA,MAAM,0BAA2BA,CAAK,CAChD,CACF,KAGK,IAAM,CACGP,EAAA,EAAA,CAEf,EAAA,CAACtB,EAAaD,EAAMe,CAAS,CAAC,EAC1BZ,CACT"}